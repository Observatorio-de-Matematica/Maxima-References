/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: input   start ] */
/* Date: Wed Jan 21 21:01:38 WET 2004 */
/* Contributor: Barton Willis */
/* Description: does the same as rationalize */
float2rational(x) := (
      if ?floatp(x) then (
         x : ?rational(x),
         ?numerator(x) / ?denominator(x))
      else x)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Tue Jan 6 08:11:19 WET 2009 */
/* Contributor: Luigi Marino */
/* Description: Implementation of bisection method */
segno(x):=block(
    [],
    if x=0 then return(0) else (if x>0 then return(1) else return(-1) )
)$
bisez(funz,var,a,b,eps,numiter):=block(
    [fa,fb,fc,c,l,k],
    define(f(var),funz),
    fa:f(a),
    fb:f(b),
    l:abs(b-a),
    k:0,
    if segno(fa)#segno(fb) then do (
        k:k+1,
        l:l/2.0,
        c:ev(a+(b-a)/2.0,float),
        fc:f(c),
        if (fc=0.0 or l<eps or k>numiter) then (
            print("c=",c," in ",k," iterazioni"),
            return(fine)
        ) else (
            if (segno(fa)*segno(fc)>0) then (a:c, fa:fc) else (b:c, fb:fc) 
        )
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sat Nov 26 19:17:36 WET 2005 */
/* Contributor: Robert Dodier */
/* Description: an implementation of Newton method */

NEWTONEPSILON:10.0^(-fpprec/2)$
NEWTONMAXITER:50$

mnewton(FuncList, VarList, GuessList):=
  block([nfunc, Solutions, Increments, solved:false, h,
         i, j, k, keepfloat:true, ratprint:false],

    /* Depuration of the function arguments */
    GuessList:float(GuessList),
    nfunc:length(FuncList),
    if length(VarList) # nfunc then (
      print("mnewton: incorrect number of variable names (", nfunc,
            "functions but", length(VarList), "variable names)."),
      return(false)
    ),
    if length(GuessList) # nfunc then (
      print("mnewton: incorrect number of approach values (", nfunc,
            "variables but", length(GuessList), "approximation values)."),
      return(false)
    ),
    apply(kill, VarList),

    DF: zeromatrix (nfunc, nfunc),
    h : makelist (h[i], i, 1, nfunc),
    for i:1 thru nfunc do
      for j:1 thru nfunc do
        DF[i][j] : diff (FuncList[i], VarList[j]),  /* Jacobian matrix */

    GuessList: float (GuessList),
print ("DEBUG: initial GuessList:", GuessList),

    /* Solution of the functions system */
    for k:1 thru NEWTONMAXITER do (
      Solutions:map("=", VarList, GuessList),

      /* Solve 0 = F(x) + DF(x) h for h.
       */
      block
        ([DFx: sublis (Solutions, DF),
        Fx: sublis (Solutions, FuncList)],
        Increments: linsolve (transpose (DFx . h + Fx)[1], h)),

      GuessList:GuessList + map (rhs, Increments),
      GuessList: float (GuessList),
print ("DEBUG: Increments:", Increments, "GuessList:", GuessList),

      solved:true,
      for i:1 thru nfunc do
        solved: solved and abs (rhs (Increments[i])) < NEWTONEPSILON,
      if solved then return(0)
    ),

    /* Return of solution or error */
    if solved = false then (
      print("mnewton: the process doesn't converge or it converges too
slowly."),
      return([])
    ),
    Solutions:map("=", VarList, GuessList),
print ("DEBUG: sublis (Solutions, FuncList) =>", sublis (Solutions, FuncList)),
    return([Solutions])
  )$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* Date: Sun Oct 2 00:17:05 WEST 2005 */
/* Contributor: Mario Rodriguez Riotorto */
/* Description: define Lagrange interpolation */
lagrange(tab) := block([n:length(tab),sum:0,prod],
   for i:1 thru n do(
      prod: 1,
      for k:1 thru n do
         if k#i then prod: prod * ('x-tab[k][1]) / (tab[i][1]-tab[k][1]),
      sum: sum + prod * tab[i][2] ),
   ratsimp(sum) )$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Fit(data, functionlist, vars) := block(
     [numer:true,float:true,
     lambdalist, design_matrix,
     alpha_matrix, beta_vector, sol,
     vector_b],
    lambdalist: map(
        lambda([what], apply( 'lambda, what) ),
        makelist( [vars,functionlist[function_index]] , function_index, 1,
            length(functionlist)) ),
    design_matrix:makelist(makelist(apply(lambdalist[function_index],makelist(data[data_index][k], k, 1 , length(vars)) ),
            function_index, 1, length(functionlist)),
        data_index, 1, length(data)),
    vector_b:makelist(
        data[data_index][length(vars) + 1],
        data_index, 1, length(data)),
    design_matrix: apply('matrix, design_matrix),
    alpha_matrix: transpose(design_matrix) . design_matrix,
    beta_vector: transpose(design_matrix) . vector_b,
    sol:  alpha_matrix^^-1 . beta_vector,
    sol: subst( '"[", 'matrix , transpose(sol) )[1],
    apply("+" , sol * functionlist )
) $
data2d: [ [1, 2, 2] , [ 3, 2, 5], [1, 5, 4], [3, 5, 5],[2,1,3],[-1,0,7]] $
fit2d: Fit( data2d, [1,x,y,x*y], [x,y] );
wxdraw3d(
color = red,
point_size = 3, point_type = 7,
points(data2d),
color = black,
explicit( fit2d , x, -1, 4, y, 0, 5)
)$
/* 1d example, 1000 points */
dejta: makelist( [float(i/50), sin(i/50)+random(0.2)] , i, 0, 1000),numer$
fit:Fit( dejta, [1, x, sin(x)], [x]);
wxdraw2d(
color = blue,
points(dejta),
color = red,
explicit( fit, x, dejta[1][1]-1, dejta[length(dejta)][1]+1)
) $
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
